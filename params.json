{"name":"Refresh-java","tagline":"","body":"-   What is Java\r\n-   Hello World\r\n    -   Looping around loops\r\n-   Data Types\r\n-   Functions (or Methods)\r\n    -   Overloading\r\n-   Collections\r\n    -   Strings\r\n-   Arrays\r\n    -   Maps (Dictionary)\r\n-   Classes\r\n    -   Overriding Methods\r\n    -   `extends`\r\n    -   `super`\r\n    -   Overriding Methods\r\n    -   `extends`\r\n    -   `super`\r\n-   Swing\r\n\r\nWhat is Java\r\n============\r\n\r\nJava is an object-orientated programming language. It is probably the\r\nmost widely taught and popular programming language.\r\n\r\nA few differences compared to python\r\n\r\n1.  Every Java program must define a class, and all code must reside in\r\n    this class.\r\n2.  Statically typed! Everything must have a type.\r\n3.  Must have the function: `public static void main(String[] args)`\r\n\r\nHello World\r\n===========\r\n\r\nIf there is one thing constant in Java programs, then it is the\r\nstructure of a program. It is not the same as Python in which \"Hello\r\nWorld\" can be simply written as:\r\n\r\n``` {.python}\r\nprint \"Hello World\"\r\n```\r\n\r\nRather in Java, there is a set structure\r\n\r\n``` {.java}\r\npublic class Hello {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"Hello World!\");\r\n    }\r\n}\r\n```\r\n\r\nTo run it we have to make sure we do a few things:\r\n\r\n1.  The file must be \"Hello.java\".\r\n2.  We must first compile it by running `$ javac Hello.java`\r\n3.  Then we can execute it by running `$ java Hello`\r\n\r\nRemember in section 1 where I said everything in Java code must be in a\r\nclass? Well we just saw that in the previous section.\r\n\r\nMore on classes later in section 11. In Java, conditionals and boolean\r\nvalues work in the same way that you would expect.\r\n\r\nSo lets implement a simple program which does the following:\r\n\r\n1.  Takes a single argument (a persons age)\r\n2.  Determines whether the person is:\r\n\r\n-   A child\r\n-   A teenageer\r\n-   An adult\r\n-   Pensioner\r\n\r\n(for now let us ignore wrong input)\r\n\r\nIn Python the program would look something like this:\r\n\r\n``` {.python}\r\nimport sys\r\n\r\nage = int(sys.argv[1])\r\n\r\nif age < 13:\r\n    print \"Child\"\r\nelif age <= 19:\r\n    print \"Teenager\"\r\nelif age < 65:\r\n    print \"Adult\"\r\nelse:\r\n    print \"Pensioner\"\r\n```\r\n\r\nIn Java it looks quite similar:\r\n\r\n``` {.java}\r\npublic class ageGroup {\r\n    public static void main (String[] args) {\r\n        int age;\r\n        age = Integer.parseInt(args[0]);\r\n        if (age < 13) {\r\n            System.out.println(\"Child\");\r\n        }\r\n        else if (age <= 19) {\r\n            System.out.println(\"Teenager\");\r\n        }\r\n        else if (age < 65) {\r\n            System.out.println(\"Adult\");\r\n        }\r\n        else {\r\n            System.out.println(\"Pensioner\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nJava also has a `switch` statement which will be ignored for now.\r\n\r\nBoolean statements work using `!`, `&&`, `||` instead of `not`, `and`,\r\n`or`. But otherwise works in exactly the same way.\r\n\r\nLooping around loops\r\n--------------------\r\n\r\nLoops aren't as nice as Python. For example in Python, we can use a loop\r\nto print out the numbers from one to 10.\r\n\r\n``` {.python}\r\nfor x in range(10):\r\n    print x+1\r\n```\r\n\r\nIn Java it isn't so trivial.\r\n\r\n``` {.java}\r\npublic class loop10 {\r\n    public static void main (String[] args) {\r\n        for (int i=1; i<=10; i++) {\r\n            System.out.println(i);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nSo we see that we have to declare the index `i`, specify the condition\r\nto break, and increment it.\r\n\r\nData Types\r\n==========\r\n\r\nRemember how I said Java is statically typed? In fact, I have already\r\nintroduced this to you! In the previous section I initialised `age` by\r\ntyping `int age`. This is esentially what it means is that the type of a\r\nvariable is known at compile time.\r\n\r\nJava only supports the primitive data type which are:\r\n\r\n-   `int`\r\n-   `float`\r\n-   `double`\r\n-   `char`\r\n-   `boolean`\r\n\r\nYou will notice that there is no `string` type (`char` and `string`\r\ntypes are different).\r\n\r\nBut! Java does have a `String` *reference* type (`string` with a capital\r\n`S` and yes, it does make a difference). We will see more about it in\r\nsection 6.\r\n\r\nThere isn't too much to demonstrate here, as all these things will work\r\nin the same way as Python.\r\n\r\nFunctions (or Methods)\r\n======================\r\n\r\nFunctions are important part of any program. Here is an example of a\r\nsimple function which takes a string and prints it. (Note in Java this\r\nis normally called a \"method\")\r\n\r\n``` {.java}\r\n// simplePrint java program\r\n// simple function example\r\n\r\npublic class simplePrint {\r\n    public static void pprint(String s) {\r\n        // a void method that just prints a string\r\n        System.out.println(\"This is a string: \" + s);\r\n    }\r\n    \r\n    public static void main(String[] args) {    \r\n        String ex = new String(\"test\");        \r\n        pprint(ex);\r\n        pprint(\"a\");\r\n    }\r\n}\r\n```\r\n\r\nSince the function doesn't return anything we have to give it a return\r\ntype of \"void\". The rest of the function is extremely similar to Python.\r\n\r\n### Overloading\r\n\r\nMethods can be overloaded. You can define two methods with the **same**\r\nname, but with different types, and it will run as expected.\r\n\r\nFor example, altering the program above to do something else for `int`\r\ntypes, we can see:\r\n\r\n``` {.java}\r\npublic class overloadPrint {\r\n    public static void pprint(String s) {\r\n        System.out.println(\"This is a string: \" + s);\r\n    }\r\n    \r\n    public static void pprint(int s) {\r\n        System.out.println(\"We 'found' an int!\");\r\n    }\r\n    \r\n    public static void main(String[] args) {    \r\n        String ex = new String(\"test\");        \r\n        pprint(ex);\r\n        pprint(\"a\");\r\n        pprint(2);\r\n    }\r\n}\r\n```\r\n\r\nCollections\r\n===========\r\n\r\nCollections are analogous to Python's list, tuples and dicts.\r\nCollections include:\r\n\r\n-   Strings\r\n-   Arrays\r\n-   Lists\r\n-   Sets\r\n-   Dictionaries or Maps\r\n-   Iterators\r\n\r\nThese are reference types and are actually objects (at least from my\r\nunderstanding). Which means they cannot be used in the same way as the\r\nprimitive types.\r\n\r\nStrings\r\n-------\r\n\r\n`String` is **not** the same as Python strings! Lets take a quick look\r\nat something we would expect to work in Python \"translated\" into Java.\r\n\r\n``` {.java}\r\npublic class wrongString {\r\n    public static void main(String[] args) {\r\n        String a = new String(\"test\");\r\n        String b = new String(\"test\");\r\n        \r\n        if (a == b) {\r\n            System.out.println(\"Equal!\");\r\n        }\r\n        else {\r\n            System.out.println(\"Not Equal!\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWhy does this happen! Well the reason is simply because `==` tests for\r\n*reference* equality while what we want is *value* equality.\r\n\r\nSo lets look at the correct way:\r\n\r\n``` {.java}\r\n//rightString.java is the right way to compare strings\r\n\r\npublic class rightString {\r\n    public static void main(String[] args) {\r\n        String a = new String(\"test\");\r\n        String b = new String(\"test\");\r\n        \r\n        if (a.equals(b)) {\r\n            System.out.println(\"Equal!\");\r\n        }\r\n        else {\r\n            System.out.println(\"Not Equal!\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWe will use the `.equals` method in order to compare if strings are the\r\nsame.\r\n\r\nWhat about comparing strings if they are \"bigger\" or \"smaller\"? Simply\r\nuse `compareTo` method.\r\n\r\n``` {.java}\r\n// orderString shows a way to compare whether strings are \"bigger\"\r\n// or \"smaller\"\r\n\r\npublic class orderString {\r\n    public static void main(String[] args) {\r\n        String a = new String(\"a\");\r\n        String b = new String(\"b\");\r\n        \r\n        int compare = a.compareTo(b);\r\n        \r\n        if (compare < 0) {\r\n            System.out.println(a + \" comes before \" + b);\r\n        }\r\n        else if (compare == 0) {\r\n            System.out.println(a + \" is equal to \" + b);\r\n        }\r\n        else { \r\n            System.out.println(a + \" comes after \" + b);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nArrays\r\n======\r\n\r\nYou can declare an array of \"things\" quite easily in Java. There really\r\nisn't a Python \"version\" of an array, though you can think of an array\r\nas a list of fixed length and can only contain one variable type.\r\n\r\n``` {.java}\r\npublic class intArray {\r\n    public static void main(String[] args) {\r\n        int[] numArr = {1,2,3,4};\r\n        for (int i=0; i<4; i++) {\r\n            System.out.println(numArr[i]);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nYou can also preallocate the array size and assign the values later.\r\n\r\n``` {.java}\r\npublic class intArrayFixed {\r\n    public static void main(String[] args) {\r\n        int[] numArr = new int[4];\r\n        \r\n        for (int i=0; i<4; i++) {\r\n            numArr[i]=i+1; // indexing starts from 0\r\n        }        \r\n        for (int i=0; i<4; i++) {\r\n            System.out.println(numArr[i]);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nMaps (Dictionary)\r\n-----------------\r\n\r\nPython dictionaries are known as \"maps\" in Java. There are two different\r\nmaps that are in Java:\r\n\r\n-   `HashMap`\r\n-   `TreeMap`\r\n\r\nLets just look at the example below.\r\n\r\n``` {.java}\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.lang.Math;\r\n\r\npublic class simpleMap {\r\n    public static void main(String[] args) {\r\n        Map<String, Integer> names = new HashMap<String, Integer>();\r\n        \r\n        //associate a random age with each name\r\n        for (int i=1; i<=10; i++) {\r\n            String name = \"name\"+i;\r\n            names.put(name, (int)(Math.random() * 10+1));\r\n        }\r\n        \r\n        //print them all out, the keys and the values\r\n        for (String key : names.keySet()) {\r\n            System.out.println(key + \" \" + names.get(key));\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWe can see here, there are some things that may look familiar to Python\r\nprogrammers.\r\n\r\nFirstly, we now have the `import` statement. This works much in the same\r\nway as how Python has implemented it.\r\n\r\nClasses\r\n=======\r\n\r\nClasses in Java are unavoidable. Everything has to reside in a class!\r\nBut lets look at a more complex example, defining our own data type\r\nbeing \"Fractions\".\r\n\r\n``` {.java}\r\npublic class Fraction {\r\n    // initialise!\r\n    private Integer numerator;\r\n    private Integer denominator;\r\n    \r\n    //constructor\r\n    public Fraction(Integer numerator, Integer denominator) {\r\n        this.numerator = numerator;\r\n        this.denominator = denominator;\r\n    }\r\n    \r\n    public Fraction(Integer numerator) {\r\n        this.numerator = numerator;\r\n        this.denominator = 1;\r\n    }\r\n    \r\n    //functions to just get the numerator/denominator\r\n    public Integer getNumerator() {\r\n        return numerator;\r\n    }\r\n    \r\n    public Integer getDenominator() {\r\n        return denominator;\r\n    }\r\n    \r\n    // add some simple methods like addition, subtraction\r\n    public Fraction add(Fraction f2) {\r\n        Integer nNum, nDenom;\r\n        nNum = f2.getDenominator()*numerator + denominator*f2.getNumerator();\r\n        nDenom = denominator*f2.getDenominator();\r\n        return new Fraction(nNum, nDenom);    \r\n    }\r\n    \r\n    public Fraction add(Integer f1) {\r\n        return add(new Fraction(f1));\r\n    }\r\n    \r\n    \r\n    // add a print method\r\n    public static void printFraction(Fraction f) {\r\n        System.out.println(f.numerator + \"/\" + f.denominator);\r\n    }\r\n\r\n    public static void main(String[] args) {    \r\n        Fraction t1 = new Fraction(10);\r\n        Fraction t2 = new Fraction(1,2);\r\n        \r\n        printFraction(t1.add(t2));\r\n    }\r\n\r\n}\r\n```\r\n\r\nBefore diving in too deep, lets ask the question, why doesn't\r\n`System.out.println(f.numerator);` work? The simple reason is that\r\n`numerator` is `private`. In order to allow the `println` function to\r\nwork we would have to change it to `public`. This is designed to control\r\naccess to members in a class.\r\n\r\nLets take a moment to think about how inheritance is handled in other\r\nprogramming languages. The typical example is using \"Animals\". In Python\r\nthis is accomplished by first defining a class, and then wrapping a sub\r\nclass underneath.\r\n\r\nFor example:\r\n\r\n``` {.python}\r\n\r\nclass Animal(object):\r\n    def __init__(self, name, species):\r\n        self.name = name\r\n        self.species = species\r\n    def getName(self):\r\n        self.name\r\n\r\n    def getSpecies(self):\r\n        self.species\r\n\r\n    def __str__(self):\r\n        return \"%s is a %s\" % (self.name, self.species)\r\n\r\ndef main():\r\n    dog = Animal(\"Bob\", \"Dog\")\r\n    print dog\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n\r\n```\r\n\r\nSo then, to inherit, lets say we have a dog and want to add a breed:\r\n\r\n``` {.python}\r\n\r\nclass Animal(object):\r\n    def __init__(self, name, species):\r\n        self.name = name\r\n        self.species = species\r\n    def getName(self):\r\n        self.name\r\n\r\n    def getSpecies(self):\r\n        self.species\r\n\r\n    def __str__(self):\r\n        return \"%s is a %s\" % (self.name, self.species)\r\n\r\nclass Dog(Animal):\r\n\r\n    def __init__(self, name, breed):\r\n        Animal.__init__(self, name, \"Dog\")\r\n        self.breed = breed\r\n\r\ndef main():\r\n    muffins = Animal(\"Muffins\", \"Cat\")\r\n    dog = Dog(\"Bob\", \"Bulldog\")\r\n    print muffins\r\n    print dog\r\n    print dog.breed\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n\r\n```\r\n\r\nAnd thats it! You now have some form of inheritance.\r\n\r\nSo in Java what would this look like?\r\n\r\n``` {.java}\r\n\r\n// animals\r\n\r\nclass Animal {\r\n    private String name;\r\n    private String species;\r\n    \r\n    public Animal(String name, String species) {\r\n        this.name = name;\r\n        this.species = species;\r\n    }\r\n    \r\n    @Override\r\n    public String toString() {\r\n        return name + \" is a \" + species;\r\n    }\r\n}\r\n\r\nclass Dog extends Animal {\r\n    private String breed;\r\n    \r\n    public Dog(String name, String breed) {\r\n        super(name, \"Dog\");\r\n        this.breed = breed;\r\n    }\r\n    \r\n    public void printBreed() {\r\n        System.out.println(breed);\r\n    }\r\n}\r\n\r\npublic class printAnimal {\r\n\r\n    public static void main(String[] args) {    \r\n        Animal muffins = new Animal(\"Muffins\", \"Cat\");        \r\n        Dog bob = new Dog(\"Bob\", \"Bulldog\");\r\n        System.out.println(muffins);\r\n        bob.printBreed();\r\n    }\r\n}\r\n```\r\n\r\nWhat are the differences that we see?\r\n\r\n1.  Method overriding via `@Override`.\r\n2.  Use of the word `extends`.\r\n3.  Method `super`.\r\n\r\nSo lets go through briefly what each one of these things actually do.\r\n\r\n### Overriding Methods\r\n\r\nYou can override methods in Java by using `@Override`. In Python this\r\nwas done through `__str__`.\r\n\r\n### `extends`\r\n\r\nThis is the Java way of inheritance.\r\n\r\n### `super`\r\n\r\nThis is the Java equivalent of this python line:\r\n\r\n``` {.python}\r\nAnimal.__init__(self, name, \"Dog\")\r\n```\r\n\r\nIt is where all the magic happens when it calls its super class to\r\n\"inherit\" it.\r\n\r\nLets take a moment to think about how inheritance is handled in other\r\nprogramming languages. The typical example is using \"Animals\". In Python\r\nthis is accomplished by first defining a class, and then wrapping a sub\r\nclass underneath.\r\n\r\nFor example:\r\n\r\n``` {.python}\r\n\r\nclass Animal(object):\r\n    def __init__(self, name, species):\r\n        self.name = name\r\n        self.species = species\r\n    def getName(self):\r\n        self.name\r\n\r\n    def getSpecies(self):\r\n        self.species\r\n\r\n    def __str__(self):\r\n        return \"%s is a %s\" % (self.name, self.species)\r\n\r\ndef main():\r\n    dog = Animal(\"Bob\", \"Dog\")\r\n    print dog\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n\r\n```\r\n\r\nSo then, to inherit, lets say we have a dog and want to add a breed:\r\n\r\n``` {.python}\r\n\r\nclass Animal(object):\r\n    def __init__(self, name, species):\r\n        self.name = name\r\n        self.species = species\r\n    def getName(self):\r\n        self.name\r\n\r\n    def getSpecies(self):\r\n        self.species\r\n\r\n    def __str__(self):\r\n        return \"%s is a %s\" % (self.name, self.species)\r\n\r\nclass Dog(Animal):\r\n\r\n    def __init__(self, name, breed):\r\n        Animal.__init__(self, name, \"Dog\")\r\n        self.breed = breed\r\n\r\ndef main():\r\n    muffins = Animal(\"Muffins\", \"Cat\")\r\n    dog = Dog(\"Bob\", \"Bulldog\")\r\n    print muffins\r\n    print dog\r\n    print dog.breed\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n\r\n```\r\n\r\nAnd thats it! You now have some form of inheritance.\r\n\r\nSo in Java what would this look like?\r\n\r\n``` {.java}\r\n\r\n// animals\r\n\r\nclass Animal {\r\n    private String name;\r\n    private String species;\r\n    \r\n    public Animal(String name, String species) {\r\n        this.name = name;\r\n        this.species = species;\r\n    }\r\n    \r\n    @Override\r\n    public String toString() {\r\n        return name + \" is a \" + species;\r\n    }\r\n}\r\n\r\nclass Dog extends Animal {\r\n    private String breed;\r\n    \r\n    public Dog(String name, String breed) {\r\n        super(name, \"Dog\");\r\n        this.breed = breed;\r\n    }\r\n    \r\n    public void printBreed() {\r\n        System.out.println(breed);\r\n    }\r\n}\r\n\r\npublic class printAnimal {\r\n\r\n    public static void main(String[] args) {    \r\n        Animal muffins = new Animal(\"Muffins\", \"Cat\");        \r\n        Dog bob = new Dog(\"Bob\", \"Bulldog\");\r\n        System.out.println(muffins);\r\n        bob.printBreed();\r\n    }\r\n}\r\n```\r\n\r\nWhat are the differences that we see?\r\n\r\n1.  Method overriding via `@Override`.\r\n2.  Use of the word `extends`.\r\n3.  Method `super`.\r\n\r\nSo lets go through briefly what each one of these things actually do.\r\n\r\n### Overriding Methods\r\n\r\nYou can override methods in Java by using `@Override`. In Python this\r\nwas done through `__str__`.\r\n\r\n### `extends`\r\n\r\nThis is the Java way of inheritance.\r\n\r\n### `super`\r\n\r\nThis is the Java equivalent of this python line:\r\n\r\n``` {.python}\r\nAnimal.__init__(self, name, \"Dog\")\r\n```\r\n\r\nIt is where all the magic happens when it calls its super class to\r\n\"inherit\" it.\r\n\r\nLooking at the previous example, we have just introduced the idea of\r\n*polymorphism*. There are methods and attributes that are in the\r\nsubclass \"Dog\" which are not in animal, namely the method `printBreed()`\r\nand the field `breed`. Abstract classes and interfaces are used in Java\r\nto offer a structure of the class (and subclasses) without really saying\r\nwhat it **must** do. So its like a skeleton, or outline to what is to\r\nhappen.\r\n\r\nWhat are the differences between abstract classes and interfaces? In a\r\nnutshell it could be framed like this:\r\n\r\n> Abstract classes are *guidelines*, while interfaces are *rules*.\r\n\r\n<!--\r\nneeds to be expanded\r\n-->\r\n\r\n\r\nSwing\r\n=====\r\n\r\nSwing is a nice easy way to create GUI for Java programs. You can use it\r\nto accept input. So looking back at our example about getting a person's\r\nage group:\r\n\r\n``` {.java}\r\n\r\npublic class ageGroup {\r\n\r\n    public static void printAge(int age) {\r\n        if (age < 13) {\r\n            System.out.println(\"Child\");\r\n        }\r\n        else if (age <= 19) {\r\n            System.out.println(\"Teenager\");\r\n        }\r\n        else if (age < 65) {\r\n            System.out.println(\"Adult\");\r\n        }\r\n        else {\r\n            System.out.println(\"Pensioner\");\r\n        }\r\n    }\r\n\r\n    public static void main (String[] args) {\r\n        int age;\r\n        age = Integer.parseInt(args[0]);\r\n        printAge(age);\r\n    }\r\n}\r\n```\r\n\r\nNow we want to add a dialog box to get our input.\r\n\r\n``` {.java}\r\n\r\nimport javax.swing.*;\r\n\r\npublic class ageGroup {\r\n\r\n    public static String printAge(int age) {\r\n        if (age < 13) {\r\n            return \"Child\";\r\n        }\r\n        else if (age <= 19) {\r\n            return \"Teenager\";\r\n        }\r\n        else if (age < 65) {\r\n            return \"Adult\";\r\n        }\r\n        else {\r\n            return \"Pensioner\";\r\n        }\r\n    }\r\n\r\n    public static void main (String[] args) {\r\n        String getAge;\r\n        Integer age;\r\n        \r\n        getAge = JOptionPane.showInputDialog(\"Enter your age\");\r\n        age = new Integer(getAge);\r\n        \r\n        JOptionPane.showMessageDialog(null, \"You are a \" + printAge(age));\r\n    }\r\n}\r\n\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}